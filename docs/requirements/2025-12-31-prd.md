# **Monarch - Product Requirements Document**

Author: Ichsan  
Date: 2025-12-30  
Version: 2.5

## **Executive Summary**

Monarch is an open-source, AI-native task management platform designed to prevent "architectural drift" in agentic workflows. Unlike human-centric tools (Jira, Linear), Monarch acts as an Execution Supervisor. It wraps task completion in strict, executable Non-Functional Requirement (NFR) Gates.

The system utilizes the Supervisor Pattern: it runs locally alongside the developer's code, utilizing Docker sidecars to validate agent work against defined quality templates (Security, Performance, Testing) before allowing task closure.

### **What Makes This Special**

The Supervisor Pattern & NFR Gates:  
Monarch doesn't just track tasks; it enforces quality. By running ephemeral Docker containers to validate code (Tier A/B/C gates) and acting as a "Translation Layer" for tool output, it actively prevents Agent hallucination and architectural drift.

## **Project Classification**

Technical Type: Developer Platform (Local)  
Domain: DevOps / AI-Native  
Complexity: High  
A local-first, self-hosted platform running as a Go binary with Docker sidecars, managing external Agent processes via Model Context Protocol (MCP).

### **Domain Context**

This project operates at the intersection of **Docker Orchestration** and **AI Agent Protocols (MCP)**. High complexity arises from:

1. **Sidecar Management:** Orchestrating ephemeral containers for validation.  
2. **Protocol Translation:** Converting raw tool logs (SARIF, JSON) into agent-readable "Unified Error Objects".  
3. **Circuit Breaking:** Managing infinite loops in non-deterministic agent behavior.

## **Success Criteria**

1. **Zero Architectural Drift:** Managed agents cannot close tasks without passing defined NFR gates.  
2. **100% Reliable Gate Execution:** Validation containers (Standard, Script, LLM Eval) run and report deterministically.  
3. **Effective Circuit Breaking:** Infinite agent loops are detected and blocked (default 5 attempts) without human intervention.  
4. **Seamless Integration:** Works out-of-the-box with standard stacks (Go, TS, Python) via auto-detection.

## **Product Scope**

### **MVP - Minimum Viable Product**

* **Core Platform:** Single Go binary (HTTP API, MCP Server, State Management).  
* **Storage:** PostgreSQL 16 + pgvector (for semantic task history).  
* **Execution Engine:** Docker SDK orchestration for ephemeral runner containers.  
* **Agent Interface:** MCP Server exposing "Planner" and "Builder" toolsets.  
* **Human Interface:** Vue.js + Shadcn Dashboard (Kanban, Live Inspection).  
* **Gate System:** Support for Tier A (Standard), Tier B (Script), and Tier C (LLM Eval) gates.  
* **Resilience:** Circuit Breaker logic (5 failures = BLOCKED).

### **Growth Features (Post-MVP)**

* **Cloud Sync:** Optional synchronization of state for team visibility.  
* **Multi-User/Team:** Role-based access control for shared instances.  
* **Gate Marketplace:** Community-shared validation templates.  
* **Remote Runners:** Offloading validation to a remote cluster (k8s).  
* **Ghost Mode (Passive Observation):** A configuration setting where Gates run and log failures but do not block task transitions. Enables safe "burn-in" periods for teams adopting Monarch without stopping work.  
* **LLM Cost Estimation:** A pre-flight check in the UI/MCP that displays estimated token usage and cost before executing Cognitive/LLM Gates, allowing users to make informed budget decisions.  
* **Multi-Provider LLM Support:** Expansion of the LLM configuration to support OpenAI, Anthropic, and local models (Ollama) beyond the MVP's exclusive Gemini support.

### **Vision (Future)**

To become the standard **Execution Supervisor** for autonomous software engineering, where humans define the *what* (Requirements/Gates) and agents handle the *how*, with Monarch guaranteeing the bridge between them.

## **Domain-Specific Requirements**

**AI/Agent Interaction:**

* **Hallucination Control:** System must not pass raw logs to agents; it must normalize errors to specific file/line locations.  
* **Context Retrieval:** System must provide the tooling and API for semantic search over past tasks, allowing external workflows to retrieve relevant history on demand.

**DevOps/Localhost:**

* **Security:** Platform must bind to localhost by default but allow LAN access (0.0.0.0) optionally.  
* **Isolation:** All validation must happen in Docker containers to prevent agents from polluting the host environment.

## **Project Type Specific Requirements**

### **Data Model Constraints**

* **Tasks:** Must store gate_state (JSONB) and embedding (VECTOR 1536).  
* **Projects:** Must map to a local root_path.  
* **Logs:** Must be parsed into LogEntry {Severity, File, Line, Message, Tool}.

### **Interfaces**

* **MCP Protocol:** Must support SSE transport for Model Context Protocol.  
* **Real-time:** Dashboard must use EventSource (SSE) for live updates of validation status.

## **User Experience Principles**

* **"Fleet Command" Aesthetic:** The UI should feel like a mission control centerâ€”high information density, dark mode default, "breathing" status indicators.  
* **Transparency:** Always show *why* a gate failed (Raw Logs + Parsed Output).  
* **Human Authority:** The human always has a "Force Pass" override button (Break Glass).

## **Functional Requirements**

**User & Project Management**

* FR1: Users can register local projects by specifying a root file path.  
* FR2: System checks for an existing .monarch/gates.yaml configuration upon registration, falling back to auto-detection of the technology stack (Go, TS, Python) only if absent.  
* FR3: Users can configure custom gates via .monarch/gates.yaml in the project root.

**Task Management**

* FR4: Users/Agents can create tasks with Title, Description, and Template reference.  
* FR5: System stores vector embeddings of tasks for semantic search.  
* FR6: Users can view tasks on a Kanban board (Backlog, In Progress, Validating, Done, Blocked).

**Agent Interface (MCP)**

* FR7: Agents can query the project list and available quality gates (Planner Protocol).  
* FR8: Agents can search past tasks using natural language queries (Planner Protocol).  
* FR9: Agents can claim a task, transitioning it to IN_PROGRESS (Builder Protocol).  
* FR10: Agents can submit an attempt, triggering the Validation Runner (Builder Protocol).

**Execution & Validation (The Runner)**

* FR11: System spins up ephemeral Docker containers to execute defined gates.  
* FR12: System parses raw tool output (JSON, XML) into Unified Error Objects. **Crucial:**  
  1. System must distinguish between VALIDATION_FAILURE (code quality issue) and SYSTEM_ERROR (tool/parser crash).  
  2. The Unified Error Object must include a hint or suggested_fix field. For Standard Gates (Tier A), Monarch's parsers must **enrich** the output by mapping known error codes/rules (e.g., eslint rule IDs) to generic fix instructions where the tool does not provide them natively.  
* FR13: System executes "LLM Eval Gates" supporting two modes:  
  * **Snapshot Mode (Default):** Sends current file content to LLM (for audits/style checks). **Constraint:** System must reject files exceeding a configurable size limit (e.g., 100KB) to prevent token exhaustion.  
  * **Diff Mode (Optional):** Sends git diff if git is initialized (for change reviews).  
  * Both modes enforce prompt isolation.  
* FR14: System blocks a task after max_attempts (default 5) consecutive failures (Circuit Breaker).  
* FR19: **Zombie Reaper:** System must scan for and terminate orphaned Monarch runner containers/volumes on startup and via periodic health checks. **Constraint:** Must explicitly filter for containers with the monarch.managed=true label to avoid terminating unrelated user containers.

**Global Platform Configuration**

* FR20: **LLM Configuration:** System must provide a secure global setting to input the **Gemini API Key**. The system will exclusively use gemini-3-pro-preview for the MVP. Support for configurable models/providers is deferred to Growth Features.  
* FR21: **Port Configuration:** System must allow configuration of the HTTP port and Bind Address via environment variable or CLI flag (e.g., MONARCH_PORT=9090) to prevent conflicts with local development servers.  
* FR22: **Global Defaults:** System must allow global overrides for Safety Limits (Circuit Breaker Max Retries, File Size Limit) in the Dashboard settings, which take precedence over project-level defaults.

**Human Dashboard & Controls**

* FR15: Users can view live streaming logs of Agent thoughts and Runner output.  
* FR16: Users can inspect file diffs (if Git available) or snapshots. **Crucial:**  
  1. UI must visually distinguish SYSTEM_ERROR (e.g., Yellow/Warning icon) from VALIDATION_FAILURE (Red/Error icon).  
  2. UI must include a **"Runner Status Widget"** displaying the state (Active/Idle/Starting) of managed warm runners.  
* FR17: Users can "Unlock" blocked tasks to reset the circuit breaker.  
* FR18: Users can "Force Pass" a specific gate override.

## **Non-Functional Requirements**

### **Performance**

* **Latency:** Dashboard updates via SSE must differ from real-time by < 200ms.  
* **Warm Execution Strategy:** Architecture should support **Per-Stack Warm Runners** (e.g., separate containers for Node vs Python) rather than a monolithic runner. These should be lazy-loaded based on the gates defined in .monarch/gates.yaml.  
* **Resource Hygiene:** Architecture must enforce a **Global Idle Timeout** (TTL) for warm runners (configurable via Dashboard, defaulting to 5m) to prevent "System Resource Leaks" (wasted host RAM) when projects are inactive. This configuration lives in the platform settings, not the project repo.  
* **Overhead:** The Platform binary should consume < 100MB RAM when idle.

### **Security**

* **Isolation:** Validation tools must strictly run within Docker containers; no host execution of untrusted validation scripts.  
* **Access:** Project registration is restricted to Human interaction (agents cannot mount arbitrary paths).

### **Reliability**

* **State:** Database (Postgres) is the single source of truth; no in-memory state loss on restart.  
* **Container Management:** The system must implement a robust state machine to track, lazy-load, and reap warm runner containers.  
* **Testability:** System architecture must support the injection of mock tool outputs (malformed & valid) to verify "Fail Closed" logic and parser resilience without relying on external tools.

## **Implementation Planning**

**Epic Breakdown** `2025-12-31-epics.md`

*This PRD captures the essence of Monarch - A Supervisor Platform for AI Agents.*  