# **Monarch - Epic Breakdown**

Author: Ichsan  
Date: 2025-12-31  
Project Level: High Complexity (System Software)  
Target Scale: Localhost / Single User

## **Overview**

This document provides the complete epic and story breakdown for **Monarch**, decomposing the requirements from the `2025-12-31-prd.md` into implementable stories.

**Living Document Notice:** This is the initial version. It will be updated after Architecture workflows add technical decisions.

### **Epics Summary**

1. **Epic 1: Core Foundation & Supervisor Engine** (Sets up the Go binary, DB, and Docker orchestration primitives).  
2. **Epic 2: Project & Gate Configuration** (Handles project registration, git detection, and gates.yaml parsing).  
3. **Epic 3: The Runner & Standard Gates** (Implements the warm runner lifecycle, tool execution, and "Fail Closed" parsers).  
4. **Epic 4: Agent Interface (MCP Server)** (Exposes the Planner/Builder protocols and manages Task state).  
5. **Epic 5: LLM Eval Engine (Tier C)** (Implements Gemini integration, Diff/Snapshot logic, and Cost safety).  
6. **Epic 6: Mission Control Dashboard** (The Vue.js frontend, SSE streaming, and human override controls).

## **Functional Requirements Inventory**

* FR1: Register project (Local path).  
* FR2: Auto-detect stack (if no config).  
* FR3: Parse .monarch/gates.yaml.  
* FR4: Create Tasks (Title/Desc/Template).  
* FR5: Vector Embeddings (pgvector).  
* FR6: Kanban Board View.  
* FR7: MCP - List Projects/Gates.  
* FR8: MCP - Search Past Tasks.  
* FR9: MCP - Claim Task (Locking).  
* FR10: MCP - Submit Attempt (Trigger).  
* FR11: Docker Container Execution.  
* FR12: Parse Output (Unified Object + Hints + Fail Closed).  
* FR13: LLM Gates (Snapshot + Diff).  
* FR14: Circuit Breaker (Max Attempts).  
* FR15: Live Streaming Logs.  
* FR16: Diff Viewer & Runner Status Widget.  
* FR17: Unlock Blocked Tasks.  
* FR18: Force Pass Gate.  
* FR19: Zombie Reaper (Cleanup).  
* FR20: Global LLM Config (Gemini Key).  
* FR21: Port Configuration.  
* FR22: Global Safety Defaults.

## **FR Coverage Map**

* **Epic 1:** FR19, FR21, NFR-Reliability (State Machine), NFR-Performance (Overhead).  
* **Epic 2:** FR1, FR2, FR3.  
* **Epic 3:** FR11, FR12, NFR-WarmExecution, NFR-Testability.  
* **Epic 4:** FR4, FR5, FR7, FR8, FR9, FR10, FR14.  
* **Epic 5:** FR13, FR20, FR22.  
* **Epic 6:** FR6, FR15, FR16, FR17, FR18, FR22.

## **Epic 1: Core Foundation & Supervisor Engine**

**Goal:** Establish the runtime environment (Go binary + Postgres) and the Docker orchestration primitives required to manage sidecars safely.

### **Story 1.1: Project Scaffold & Database Initialization**

As a Developer, I want the Monarch binary to auto-migrate the Postgres schema on startup, so that the system state is always consistent.

**Acceptance Criteria:**

* **Given** the Monarch binary is started with MONARCH_PORT env var (FR21).  
* **When** the application boots.  
* **Then** it should connect to Postgres (using a default connection string or env var).  
* **And** apply any pending Flyway/Go-Migrate migrations for the projects, tasks, and settings tables.  
* **And** enable the pgvector extension if missing.  
* **And** verify Docker socket connectivity.

**Technical Notes:**

* Stack: Go 1.21+, lib/pq or pgx.  
* Tables: projects, tasks (initial schema from PRD 3.1).

### **Story 1.2: The Zombie Reaper (Container Hygiene)**

As a System Owner, I want Monarch to kill orphaned runner containers on startup, so that my host RAM isn't consumed by crashed sessions.

**Acceptance Criteria:**

* **Given** a previous Monarch session crashed leaving containers running.  
* **When** the new Monarch process starts (Boot phase).  
* **Then** it must query Docker for containers with label monarch.managed=true (FR19).  
* **And** strictly kill/remove ONLY those containers.  
* **And** log the number of reaped zombies to stdout.

### **Story 1.3: Container Lifecycle Manager (Core State Machine)**

As an Architect, I want a robust Go struct that manages the creation and retrieval of "Warm Runners", so that I can reuse containers efficiently.

**Acceptance Criteria:**

* **Given** a request to start a runner for project X.  
* **When** the ContainerManager.GetOrStart() is called.  
* **Then** it should check if a container for that stack (e.g., monarch-runner-go) is already RUNNING.  
* **If** running, return the ID immediately.  
* **If** stopped/missing, spawn it with label monarch.managed=true and mount the project root.  
* **And** update the internal state map (ProjectID -> ContainerID).

**Technical Notes:**

* This story focuses on the "Happy Path" of starting/retrieving. Resource cleanup is handled in 1.4.

### **Story 1.4: Resource Hygiene (Idle Timeout)**

As a User, I want Monarch to stop runner containers that haven't been used recently, so that my system memory is freed up.

**Acceptance Criteria:**

* **Given** an active runner container.  
* **When** no validation requests have occurred for > 5 minutes (Global Default).  
* **Then** a background monitor (goroutine) should detect the inactivity.  
* **And** stop (not kill) the Docker container to free CPU/RAM.  
* **And** update the internal state map to "IDLE".

**Technical Notes:**

* Implements NFR-Resource Hygiene.

## **Epic 2: Project & Gate Configuration**

**Goal:** Allow users to register projects and define "What Good Looks Like" via gates.yaml.

### **Story 2.1: Project Registration & Path Validation**

As a User, I want to register a local folder path, so that Monarch knows where to look for code.

**Acceptance Criteria:**

* **Given** a local filesystem path (e.g., /Users/dev/my-app).  
* **When** I call the RegisterProject API.  
* **Then** it must validate the path exists.  
* **And** detect if .git exists in the root.  
  * **If missing:** Log warning "Git not found; Diff Mode unavailable" but **ALLOW** registration (FR1).  
  * **If found:** Enable Git capabilities.  
* **And** insert the record into the projects table.

### **Story 2.2: Gate Configuration Parser & Defaults**

As a User, I want Monarch to read my .monarch/gates.yaml or guess my stack, so that I don't have to configure everything manually.

**Acceptance Criteria:**

* **Given** a project path.  
* **When** Monarch initializes the project context.  
* **Then** look for .monarch/gates.yaml.  
* **If found:** Parse the YAML into internal struct (Tier A/B/C definitions).  
* **If missing:** Scan root for go.mod (suggest Go stack), package.json (suggest Node stack), or requirements.txt (suggest Python).  
* **And** generate an in-memory configuration based on the detection (FR2).

## **Epic 3: The Runner & Standard Gates**

**Goal:** Execute tools inside containers, parse their output safely, and return structured data.

### **Story 3.1: Universal Tool Executor (Docker Exec)**

As the System, I want to run a shell command inside a warm container and capture stdout/stderr, so that I can validate code.

**Acceptance Criteria:**

* **Given** a warm runner container ID and a command (e.g., go test ./... -json).  
* **When** Executor.Run() is called.  
* **Then** use Docker SDK ContainerExecCreate + ContainerExecAttach.  
* **And** stream the output to a buffer.  
* **And** return the raw logs and the exit code.

### **Story 3.2: Log Parser Architecture (Fail Closed)**

As an Agent, I need a reliable parsing engine that strictly rejects malformed output, so I don't get false positives.

**Acceptance Criteria:**

* **Given** the Parser interface definition.  
* **When** implementing the base Parse() method logic.  
* **Then** it must define a structured return type []LogEntry and error.  
* **Crucial (FR12):** Define a specific error type ErrSystemFailure.  
* **And** implement the logic: If error != nil OR output is empty/truncated unexpectedly, return ErrSystemFailure. This ensures the gate is marked FAILED (System) rather than PASS.

**Technical Notes:**

* This story establishes the *Interface* and *Error Types*. Concrete parsers are in 3.3.

### **Story 3.3: Concrete Tool Parsers (Go/Node)**

As the System, I want specific parsers for common tools so I can actually read go test and eslint output.

**Acceptance Criteria:**

* **Given** the Parser interface from 3.2.  
* **When** GoTestParser receives JSON output from go test -json, it must map it to LogEntry.  
* **When** ESLintParser receives JSON output from eslint -f json, it must map it to LogEntry.  
* **And** verify both parsers trigger the "Fail Closed" logic on malformed input (using Chaos Test fixtures).

### **Story 3.4: Static Hint Enrichment**

As an Agent, I want generic advice for common errors, so I don't have to search the web for every error code.

**Acceptance Criteria:**

* **Given** a parsed LogEntry with a Rule ID (e.g., G101 from gosec).  
* **When** constructing the final object.  
* **Then** check a static internal map RuleHints.  
* **If match found:** Populate the hint field (e.g., "Hardcoded credential detected. Use env vars.").  
* **If no match:** Leave hint empty.

## **Epic 4: Agent Interface (MCP Server)**

**Goal:** Provide the API surface for AI Agents to plan and execute work.

### **Story 4.1: MCP Planner Protocol (Read-Only)**

As a "Planner" Agent, I want to see projects and history, so I can decide what to do.

**Acceptance Criteria:**

* **Given** an MCP connection (SSE).  
* **When** the client calls list_projects(), return the list from DB.  
* **When** the client calls search_past_tasks(query), perform a pgvector semantic search on the tasks table and return top 5 matches (FR8).

### **Story 4.2: MCP Builder Protocol (Task Execution)**

As a "Builder" Agent, I want to claim tasks and submit code for review.

**Acceptance Criteria:**

* **Given** a task ID.  
* **When** client calls claim_task(), update status to IN_PROGRESS.  
* **When** client calls submit_attempt(), trigger the Validation Runner logic (Epic 3).  
* **Then** return the UnifiedErrorObject analysis.

### **Story 4.3: Circuit Breaker Logic**

As a User, I want to stop an agent that is failing repeatedly, to save money and time.

**Acceptance Criteria:**

* **Given** a task in IN_PROGRESS.  
* **When** submit_attempt() returns a VALIDATION_FAILURE.  
* **Then** increment attempt_count on the task.  
* **And** fetch the MaxAttempts value from Global Settings (default 5).  
* **If** attempt_count >= MaxAttempts, update status to BLOCKED.  
* **And** return a critical error to the Agent: "Task Blocked. Human intervention required."

## **Epic 5: LLM Eval Engine (Cognitive Gates)**

**Goal:** Allow semantic code review using Gemini.

### **Story 5.1: Secure Configuration Store (Backend)**

As a User, I want the system to securely store my sensitive keys and configuration limits in the database.

**Acceptance Criteria:**

* **Given** a settings table in Postgres (Key, Value, IsEncrypted).  
* **When** the ConfigService is called to save a key (e.g., GEMINI_API_KEY).  
* **Then** encrypt the value before writing to DB.  
* **When** the system starts, load and decrypt keys into memory.  
* **And** validate the Gemini key works by making a dummy call to gemini-3-pro-preview.

**Technical Notes:**

* Support storing SAFETY_FILE_SIZE_LIMIT (default 100KB) and SAFETY_MAX_RETRIES (default 5).  
* **Usage Map:** These values are configured via the Dashboard (Story 6.4) and consumed by Circuit Breaker (Story 4.3) and Snapshot Eval (Story 5.2).

### **Story 5.2: LLM Eval: Snapshot Mode**

As the System, I want to audit a file's current state using Gemini, so I can check for security or style issues.

**Acceptance Criteria:**

* **Given** a gate of type llm_eval (Snapshot Mode).  
* **When** executing the gate.  
* **Then** fetch the SAFETY_FILE_SIZE_LIMIT from settings (FR22).  
* **Then** read the full content of the target file.  
* **If** file size > Configured Limit, **FAIL** immediately (Token Safety Limit FR13).  
* **Else** construct prompt with XML tags and send to Gemini.  
* **And** parse the JSON response.

### **Story 5.3: LLM Eval: Diff Mode**

As the System, I want to review *only* what changed in a file, so I can provide context-aware feedback on the PR.

**Acceptance Criteria:**

* **Given** a gate of type llm_eval (Diff Mode) AND a git-initialized project.  
* **When** executing the gate.  
* **Then** execute git diff for the target file.  
* **And** construct prompt: "Review these changes for issues..."  
* **And** send to Gemini and parse response.

**Technical Notes:**

* Requires robust error handling if git is missing or file is untracked.

## **Epic 6: Mission Control Dashboard**

**Goal:** A real-time UI for the human supervisor to watch and intervene.

### **Story 6.1: Real-Time Task Board (Kanban)**

As a User, I want to see active tasks moving through states.

**Acceptance Criteria:**

* **Given** tasks in DB.  
* **When** opening the dashboard.  
* **Then** display columns: Backlog, In Progress, Validating, Done, Blocked.  
* **And** subscribe to SSE events to update the board in real-time (latency < 200ms).

### **Story 6.2: Runner Status Widget (Live Feedback)**

As a User, I want to *feel* that the system is alive and processing, so I trust it isn't frozen.

**Acceptance Criteria:**

* **Given** the internal state of the ContainerManager (Epic 1).  
* **When** the state is RUNNING or VALIDATING.  
* **Then** the UI widget must use animation (e.g., a "Breathing" or "Pulsing" blue glow) to indicate activity.  
* **When** the state is IDLE.  
* **Then** the widget should be static (Dimmed Green).  
* **When** an error occurs.  
* **Then** the widget should flash Red.

**Technical Notes:**

* Use CSS animations or Shadcn Badge with pulse effects.

### **Story 6.3: Human Intervention Controls**

As a User, I want to unblock a stuck agent or override a broken gate.

**Acceptance Criteria:**

* **Given** a BLOCKED task.  
* **When** I click "Unlock", reset attempt_count to 0 and status to IN_PROGRESS.  
* **Given** a failed gate.  
* **When** I click "Force Pass" (FR18), mark the gate as passed in the DB and allow the Agent to proceed.

### **Story 6.4: Global Settings Management (UI)**

As a User, I want to configure the system's safety limits and API keys from the Dashboard, so I don't have to use SQL or CLI.

**Acceptance Criteria:**

* **Given** a "Settings" page in the Dashboard.  
* **When** viewing the "LLM" tab.  
  * **Then** allow input/update of Gemini API Key (masked input).  
  * **And** trigger validation (Story 5.1 logic) on save.  
* **When** viewing the "Safety" tab.  
  * **Then** allow input of Max Circuit Breaker Retries (FR22).  
  * **And** allow input of Max File Size (KB) (FR22).  
* **And** persists changes to the settings table via API.

## **FR Coverage Matrix**

| FR ID | Description | Covered By |
| :---- | :---- | :---- |
| FR1 | Register Project (Local path) | Story 2.1 |
| FR2 | Auto-detect Stack | Story 2.2 |
| FR3 | Parse Gates.yaml | Story 2.2 |
| FR4-5 | Tasks & Vector DB | Story 1.1, 4.1 |
| FR6 | Kanban Board | Story 6.1 |
| FR7-10 | MCP Protocol | Story 4.1, 4.2 |
| FR11 | Docker Exec | Story 3.1 |
| FR12 | Parse/Fail Closed/Hint | Story 3.2, 3.3 |
| FR13 | LLM Eval Modes | Story 5.2, 5.3 |
| FR14 | Circuit Breaker | Story 4.3 |
| FR15 | Streaming Logs | Story 6.1 (implied via SSE) |
| FR16 | Status Widget | Story 6.2 |
| FR17-18 | Controls | Story 6.3 |
| FR19 | Zombie Reaper | Story 1.2 |
| FR20 | LLM Config | Story 5.1, 6.4 |
| FR21 | Port Config | Story 1.1 |
| FR22 | Global Defaults | Story 4.3, 5.2, 6.4 |

## **Summary**

Total Epics: 6  
Total Stories: 20  
Estimated Phase: MVP  
This breakdown provides a clear path from "Empty Directory" to "Working Supervisor". It prioritizes the **Safety Mechanisms** (Reaper, Circuit Breaker, Fail Closed) in the early epics to ensure the system is trustworthy before the UI is polished.  